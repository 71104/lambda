# prints a grid
let print = fn grid: natural** ->
  (grid.each fn row: natural* ->
    console.log {(row.map fn cell: natural ->
      if 0 != cell
      then '*'
      else ' ').join ''}) in

# wraps coordinates
let mod = fn i: integer, n: natural -> (i % n + n) % n in

# samples a circular array at the given index
let get = fn array: natural*, i: integer -> array[mod i array.length] in

# returns the count of live neighbors of the specified coordinates
let live_neighbors = fn grid: natural**, i: integer, j: integer ->
  {
    get (get grid (i - 1)) (j - 1),
    get (get grid (i - 1)) j,
    get (get grid (i - 1)) (j + 1),
    get (get grid i) (j - 1),
    get (get grid i) (j + 1),
    get (get grid (i + 1)) (j - 1),
    get (get grid (i + 1)) j,
    get (get grid (i + 1)) (j + 1)
  }.reduce 0 (+) in

# steps a grid to the next state
let step = fn grid: natural** ->
  (range grid.length).map fn i: integer ->
    (range grid[i].length).map fn j: integer ->
      let live_count = live_neighbors grid i j in
        if 0 != grid[i][j]
        then if 2 = live_count or 3 = live_count then 1 else 0
        else if 3 = live_count then 1 else 0 in

# initial state
let grid = {
  {0, 1, 0, 0, 0, 0, 0, 0, 0, 0},
  {0, 0, 1, 0, 0, 0, 0, 0, 0, 0},
  {1, 1, 1, 0, 0, 0, 0, 0, 0, 0},
  {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
  {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
  {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
  {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
  {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
  {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
  {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
} in

(fix fn f, grid: natural** ->
  seq
    (print grid)
    (f (step grid))) grid
