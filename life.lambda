let in_range = (v, a, b ->
    and (>= v a) (<= v b)
) in

let min = (a, b ->
    if < a b
    then a
    else b
) in

let max = (a, b ->
    if > a b
    then a
    else b
) in

let range = fix (f, a, b ->
    if > a b
    then {}
    else {a}.concat (f (+ a 1) b)
) in

let sequentially = fix (f, x ->
    f
) in

let sum = (l ->
    l.reduce (a, v -> + a v) 0
) in

let grid.slice_row = (g, i, j ->
    if in_range i 0 (- g.length 1)
    then g[i].slice (max (- j 1) 0) (min (+ j 2) g[i].length)
    else {}
) in

let grid.neighbors = (g, i, j ->
    sum {sum (grid.slice_row g (- i 1) j),
         sum (grid.slice_row g i j),
         sum (grid.slice_row g (+ i 1) j),
         - 0 g[i][j]}
) in

let grid.next_state_from = (a, n ->
    if or (= n 3) (and (= a 1) (= n 2))
    then 1
    else 0
) in

let grid.next_state = (g, i, j ->
    grid.next_state_from g[i][j] (grid.neighbors g i j)
) in

let grid.step_column = fix (f, g, i, j ->
    if in_range j 0 (- g[i].length 1)
    then {grid.next_state g i j}.concat (f g i (+ j 1))
    else {}
) in

let grid.step_row = fix (f, g, i ->
    if in_range i 0 (- g.length 1)
    then {grid.step_column g i 0}.concat (f g (+ i 1))
    else {}
) in

let grid.step = (g ->
    grid.step_row g 0
) in

let grid.advance_n_steps = fix (f, g, n ->
    if > n 0
    then f (grid.step g) (- n 1)
    else g
) in

let grid.print = (g ->
    g.forEach (r ->
        console.log (r.reduce (a, v -> + a (if = v 1 then "*" else " ")) "")
    )
) in

let m = {{0, 1, 0, 0, 0, 0, 0},
         {0, 0, 1, 0, 0, 0, 0},
         {1, 1, 1, 0, 0, 0, 0},
         {0, 0, 0, 0, 0, 0, 0},
         {0, 0, 0, 0, 0, 0, 0},
         {0, 0, 0, 0, 0, 0, 0},
         {0, 0, 0, 0, 0, 0, 0}}
in

(range 0 10).forEach (n ->
    sequentially
        (console.log (+ "Round #" n))
        (console.log "")
        (grid.print (grid.advance_n_steps m n))
        (console.log "")
)
